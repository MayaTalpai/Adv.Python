# -*- coding: utf-8 -*-
"""John Conway’s Game of Life + Simulating Alleles in Pop.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x2U1zJFvv76YgCyUdER9zdbo9TKR5eju

# John Conways Game of Life + Genetic Drift

## Base Game Parameters
1.   Any “live” cell with fewer than two “live” neighbors dies.
2.   Any live cell with two or three live neighbors lives on to the next generation
3. Any live cell with more than three live neighbors dies
4. Any dead cell with exactly three live neighbors becomes a live cell

#Initializing cells on grid with random 1 or 0 value and assign a color to 1 cells
#COMPLETED DUE APRIL 1st 2024

##random_grid(height, width, p_alive)
  **Purpose:** We want to a randomly generated grid of 1s (alive)  and 0s (dead) based on a given height/width. This generates our first generation randomly. Since generating randomly, need to provide frequency in which cells are "alive".
  
example output under hood:

    00000100
    00000101
    01000101
    01100000
    00000100


**Edit Version 2**:

Made two versions of this code, one where parameters are predefined.

 is better because the user can fully customize the enviroment size, the number of allels in the population, how dense the population is, and the colors used to represent each allele.

I solved this functionally to have one function define what colors the user picks (input_colors()) and nested that in the the random grid generator funciton (random_grid())as the  color_pallete argument .

**Edit Version 3**

Change from a list to a dictionary in "input_color_and_density() fucntion" and added calc for realtive freq/density. The dictionary allows us to map input colors to input relative frequencies. This is pivitol for later in the code accessing the keys to update the relative frequencies, add new colors and frequencies as mutations and hybrids happen, and

Goal output under hood:

  --> a big difference is the 3 channels of output representing the RGB colors

    (0,0,0)(0,0,0)(255,0,0)(0,0,0)
    (0,0,0)(255,0,0)(0,0,0)(255,0,0)
    (0,0,255)(0,0,0)(255,0,0)(0,0,255)

> Geek for Geek's random_grid(N)
    # setting up the values for the grid
    ON = 255   #<--- this is white cell
    OFF = 0    #<--- this is black cell
    vals = [ON, OFF]
  
    def randomGrid(N):
  
    '''returns a grid of NxN random values'''
    return np.random.choice(vals, N*N, p=[0.2, 0.8]).reshape(N, N)
_____________________________________________________________________
> Colorful Conway GOL Github's random_grid

    def random_grid(height, width, density=.3, padding=0):
	'''
	Gives a random 2D grid of 1s and 0s.

	Parameters:
	height (int): How many rows the grid will have
	width (int): How many columns the grid will have
	density (float): The probability any given cell will be a 1
	padding (int): If a padding value is specified, cells within the padding distance of an edge will always be 0

	Returns:
	2D list
	'''

	if not padding:
		return [[1 if random()<density else 0 for x in range(width)] for y in range(height)]
	else:
		return [[(1 if random()<density else 0) if (not (x < padding or x >= width - padding)) and (not (y < padding or y >= height - padding)) else 0 for x in range(width)] for y in range(height)]
______________________________________________________________________
>Custom one for us taking the best of both worlds

This one is the best of both examples because utilizes the numpy module to generate random cells for us, but give the flixibilty to specify probabilty of alive cells and assign a set value of colors that we can attribute a fitness score to. I dont think we need padding so dropped that.

    #specify specific colors were gonna use unmixed
    color_palette = [
    (255, 0, 0),  # Red
    (0, 255, 0),  # Green
    (0, 0, 255),  # Blue
    (255, 255, 0),  # Yellow
    # Add more colors as needed
    ]
    #function to assign alive/dead + alive ones colors
    def random_colored_grid(height, width, density=0.3):
      #Create an empty grid with size = 3 channels for RGB colors
      grid = np.zeros((height, width, 3), dtype=int)
      for i in range(height):
          for j in range(width):
              if np.random.rand() < density:
                # Assign a random color for alive cells
                grid[i, j] = np.random.randint(0, 256, size=3) #this is not exactly what we want, it assigns any color mixed, but want to start out with a pure color, so going to change this and add a color palette to pull from

      return grid
"""

#Referenced this a lot: https://numpy.org/doc/stable/reference/random/index.html
#VERSION 1 DONE or NOT DONE? DONE initializing a grid with colored cells.

import numpy as np
import matplotlib.pyplot as plt
#defining the starting values/colors for the grid. This will later be defined by "fitness", and also each iteration will be dynamic.


color_palette = [
    (255, 0, 0),  # Red
    (0, 0, 255),  # Blue
    (255, 255, 0),  # Yellow
]
def random_grid(height, width, density, alleles):
  # Initialize an empty grid. shape=(height, width, and 3) each cell in grid has 3 components for RGB value
  grid = np.zeros((height, width, 3), dtype=int)                                #np.zeros((shape)) Return a new array of given shape and type, filled with zeros. https://numpy.org/doc/stable/reference/generated/numpy.zeros.html#numpy.zeros
    # Randomly assign colors to cells based on density
  for i in range(height):
    for j in range(width):
      if np.random.rand() < density:                                            #generates a random # between 1 and 0 < probabilty of being alive (example 0.1) If True = alive cell
      # Assign a random color for alive cells
        grid[i, j] = color_palette[np.random.randint(len(color_palette))]       #from color palette, choose a random values
      # Dead cells are still [0,0,0]
  return grid

grid = random_grid(int(input("Enter enviroment height:")), int(input("Enter enviroment width:")), float(input("Enter organism's density:")))
################################################################### USED TO SEE WHAT THE INITAL PLOT LOOKS LIKE #######################
plt.imshow(grid)
plt.show()

#This isnt super great...
# Might be easier to make it more open eneded like have them pick their color however, because the # of alleles is limtied to the colors in the palletle and assigned fitness. User has to know colors in pallete and thier associted fitness score

#VERSION 2 DONE or NOT DONE? DONE More flexible and user defined parameters for initializing a grid with colored cells.
import numpy as np
import matplotlib.pyplot as plt

def input_colors(num_colors):
  # Generates the color pallete to be used in random_grid function. Gives the user freedom to pick color of alleles on RBG scale [0-255,0-255,0-255]
  color_palette = []
  for i in range(num_colors):
    print("Enter color of allele {i+1} in RGB format (r,g,b where each value is between 0-255): ")
    rgb_values = input().split(',')  # Expecting input format to be 'r,g,b'
    color = tuple(map(int, rgb_values))  # Convert input to a tuple of integers
    color_palette.append(color)
  return color_palette

def random_grid(height, width, density, color_palette):
  # Call on function that allows the user to input specific colors
  color_palette = input_colors(num_colors)
  # Initialize an empty grid.
  grid = np.zeros((height, width, 3), dtype=int) #this makes a grid of zeros of specified hxw
  # Randomly assign colors to cells based on density
  for i in range(height):
    for j in range(width):
      if np.random.rand() < density: #Generate a number between 0-1. If denisty > number genrated, that is a "alive" or 1 cell.
      # Assign a random color for "alive" or 1 cells
        grid[i, j] = color_palette[np.random.randint(len(color_palette))]
  return grid

# User input for the grid dimensions, density, and number of colors
height = int(input("Enter environment height: "))
width = int(input("Enter environment width: "))
density = float(input("Enter organism's density: "))
num_colors = int(input("Enter the number of colors (alleles): "))

# We could have user define fitness scores for each color here
#color_fitness_scores = {color: index + 1 for index, color in enumerate(color_palette)}

# Define grid variable as one with the user-defined parameters
user_grid = random_grid(height, width, density, color_palette)

##################EXAMPLE OF PLOT LOOKS LIKE-- WILL BE INPUTED INTO RULES OF GAME TO GENERATE ITERATIONS######################################
# Display the initial plot
plt.imshow(user_grid)
plt.show()

#VERSION 3 DONE or NOT DONE? DONE Addeed relative frequency as a dictionary of alleles which will go into calulating fitness
import math
from random import random
from random import uniform
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as anm
import matplotlib.colors as clrs


def input_colors_and_densities(alleles):
  color_density_map = {}  # Use a dictionary to map colors to densities, useful later for fitness calculations
  for i in range(alleles):
    rgb_values = input("Choose a color for allele " + str(i+1) + " in RGB format (r,g,b where each value is between 0-255): ")
    rgb_values = rgb_values.split(',')
    color = tuple(map(int, rgb_values))

    density = float(input("Enter the relative frequency of allele " + str(i+1) + " (value between 0 and 1): "))
    color_density_map[color] = density
  print(color_density_map) #check to see what it looks like
  return color_density_map

def random_grid(height, width, overall_density, color_density_map):
  grid = np.zeros((height, width, 3), dtype=np.uint8)
  colors = list(color_density_map.keys())
  densities = list(color_density_map.values())
  for i in range(height):
    for j in range(width):
      if np.random.rand() < overall_density:  # Decide if the cell is alive or a "1"
        color_index = np.random.choice(len(colors), p=densities)
        grid[i, j] = colors[color_index]

  return grid


# User inputs for grid dimensions and overall population density
height = int(input("Enter the environment's height: "))
width = int(input("Enter the environment's width: "))
overall_density = float(input("Enter the organisms population density (value between 0 and 1): "))

# Input specific colors for alleles and their relative densities in population
alleles = int(input("Enter the number of alleles in population: "))
color_density_map = input_colors_and_densities(alleles)

# Call random_grid to generate the grid with the user-defined parameters
user_grid = random_grid(height, width, overall_density, color_density_map)
plt.imshow(user_grid)
plt.show()

"""#Fitness Fucntion + Color

#COMPLETED DUR APRIL 22nd

**Purpose:** This function will dictate what the childrens cells color will be depending on how "fit" the parent cells are.

HUE and AVERGAE HUE from Colorful GOL Git Hub  https://github.com/adam-zheleznyak/colorful-life/blob/master/examples.py

Notes: This is not too helpful tbh. Our designs diverge a bit here as well. The ket differences are in how we fillout the next step gen, how we access the color+fitness info, and add in mutations more dynamically. Im not to sure about creating a while new class either. The average equation is close, but since our data is in (RGB) format, we need to rethink how we caluclate the new color in the average colro function. Lets take what we can from it.

      class Hue:
	'''This is a class to represent a color's hue as a float mod 1. Two Hue objects can be added together to get a new Hue object.'''

	def __init__(self, value):
		self.value = float(value % 1)

	def __bool__(self):
		return True

	def __float__(self):
		return float(self.value)

	def __repr__(self):
		return repr(self.value)

	def __add__(self, other):
		return Hue(self.value + other.value)

    def average_hue(list_of_hues):
	'''
	Gets the average hue from a list of hues.

	Parameters:
	list_of_hues (list of Hue objects)

	Returns:
	Hue
	'''

	x = 0.0
	y = 0.0
	# Take all the hues as points on a unit circle and average their coordinates to find the average
	for hue in list_of_hues:
		x += math.cos(hue.value*2*math.pi)
		y += math.sin(hue.value*2*math.pi)
	x /= len(list_of_hues)
	y /= len(list_of_hues)
	return Hue(math.atan2(y,x)/(2*math.pi))

### Version 1 Psudocode
    def color_update(gen_x_grid): #I need this to be called in a place so EVERY new grid is recounted for their colors and frequency

    take old freqencies from initialization step and and put inside a stack
    
    take color out of stack and compare to every cell. Is that color in the new grid?
    yes -->  return color to new list that will be called upon again in next iteration
    
    no--> pop color out of stack and dont append to new list


    Problems Enocuntered: This is very inefficent and since comparing using old list, when a new color is encountered it wont be recgonized and added to list.
  

    def color_fitness() #needs to run when making rules to detrmine new cell color

    --> need to count how many cells are this color in the grid

    XXX This gets hairy, need to find a way to build this in above too.
    
    Going back above to change data strucutre and make a dictionary/ access key of color:density
"""

#VERSION 1

#Need a fucntion that updates the color_density_map function from the input in te initilzation stage. This is to keep track of new colors that emerge and their relative frequency.
#This needs to be ran when we do the iterative steps.
def color_density_map_update(grid)
  color_denisity_update = {} #update = making new dictionary from old one and adding wats needed/new
  total_alive = 0
  for row in grid
    for cell in row
      if np.any(cell > 0)
        cell_color = tuple(cell)
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        tota_alive += 1
  color_density_map_update = {color: count/ total_alive for color, count in color_denisity_update.items() if total_alive > 0}  #dictionary comprehension to extract color and frequency from above.
  return color_density_map_update

#Need  a fucntion that calulates the weighted average of RBG vales based on frequency in pop.
#This needs to be ran when we make the new grid for each generation
def fitness_function(live_neighbors, color_density_map):
  # Start out with blank weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0])
  total_density = 0.0 #alive cells to track relative freq later

  # Calculate weighted sums for each color component
  for color in live_neighbors:
    n_color = tuple(color) #was having trouble, array was immutable so needed to turn to tuple.
    if n_color in color_density_map:
      density = color_density_map[n_color]
      weighted_sum += np.array(color) * density
      total_density += density

  if total_density > 0:
    new_color = (weighted_sum / total_density).astype(int)
  else:
    new_color = (0,0,0) #dead cell

  return tuple(new_color)

#VERSION 2

#used to update the color_denisty_map based on current generation, will impliment later
def color_density_map_update(grid):
  color_denisity_update = {}                                                    #empty dict to store all new + old colors that may have been "born"
  total_alive = 0                                                               #number of cells alive for realtive density
  for row in grid:
    for cell in row:
      if np.any(cell > 0):                                                      #check if alive if have rgb info
        cell_color = tuple(cell)                                                #have to turn to tuple so I can make keys for dict and search later.
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        total_alive += 1                                                         #add cell alive count

 # After counting all cells, calculate the relative density for each color/allele by dividing its count by the total number of alive cells. Going to use dictionary comprehension

  color_density_map_update = {color: count/ total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

#If you have a higher relative denisty in the population, the higher your fitness or ability to pass gene to offspring. Colors/Alleles with higher relative densities have a greater influence on the resulting color.
#Hybrids have bad realtive density though, so equals to bad fitness. In above color_denisty_update maybe have it be a very small chance that one cell if lucky and hybrid artifically has a high fitness "high-density" to equal a advantagous allele/mutation

def fitness_function(live_neighbors, color_density_map):
  # Initialize weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0]) #cumulative RGB values of neighbor livecells
  total_density = 0.0 #used to calc weighted average later

  # Calculate weighted sums for each color component
  for color in live_neighbors:                                                   #iterate over color/rbg values. this is implimented in the gen_step function, because have to be detrmined by rules as well.
    n_color = tuple(color)                                                       #have to turn to tuple to extract and use dictionary keys. *rememeber tuples immutable so can be used as keys
    if n_color in color_density_map:                                             #does color exist in dictionary
      density = color_density_map[n_color]                                       #if so get the density/relative frequency
      weighted_sum += np.array(color) * density                                  #multiply the color by the density giving it more weight, and add to weighted sum. turn back to array
      total_density += density                                                   #add density to total

  if total_density > 0:
    new_color = (weighted_sum / total_density).astype(int) #new color is the weighted sum over the total, make sure it is a whole number for rbg vale
  else:
    new_color = (0,0,0)                                                         #dead cell if no live neighbors

  return tuple(new_color)                                                       #return color for gen step

#VERSION 3 ADDED MUTATIONS TO BE MORE DEFINED (good/bad) and their effect on color
#used to update the color_denisty_map based on current generation, will impliment later
def color_density_map_update(grid):
  color_denisity_update = {}                                                    #empty dict to store all new + old colors that may have been "born"
  total_alive = 0                                                               #number of cells alive for realtive density
  for row in grid:
    for cell in row:
      if np.any(cell > 0):                                                      #check if alive if have rgb info
        cell_color = tuple(cell)                                                #have to turn to tuple so I can make keys for dict and search later.
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        total_alive += 1                                                         #add cell alive count

 # After counting all cells, calculate the relative density for each color/allele by dividing its count by the total number of alive cells. Going to use dictionary comprehension

  color_density_map_update = {color: count/ total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

#If you have a higher relative denisty in the population, the higher your fitness or ability to pass gene to offspring. Colors/Alleles with higher relative densities have a greater influence on the resulting color.
#Hybrids have bad realtive density though, so equals to bad fitness. In above color_denisty_update maybe have it be a very small chance that one cell if lucky and hybrid artifically has a high fitness "high-density" to equal a advantagous allele/mutation

def fitness_function(live_neighbors, color_density_map, mutation_rate=0.01, beneficial_mutation_multiplier = 1.25, detrimental_mutation_multiplier = 0.8): #picked multiplier and mutation rate arbutrarily
  # Initialize weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0]) #cumulative RGB values of neighbor livecells
  total_density = 0.0 #used to calc weighted average later

  # Calculate weighted sums for each color component
  for color in live_neighbors:                                                   #iterate over color/rbg values. this is implimented in the gen_step function, because have to be detrmined by rules as well.
    n_color = tuple(color)                                                       #have to turn to tuple to extract and use dictionary keys. *rememeber tuples immutable so can be used as keys
    if n_color in color_density_map:                                             #does color exist in dictionary
      density = color_density_map[n_color]                                       #if so get the density/relative frequency
      weighted_sum += np.array(color) * density                                  #multiply the color by the density giving it more weight, and add to weighted sum. turn back to array
      total_density += density                                                   #add density to total

  if total_density > 0:
    w_average_color = (weighted_sum / total_density).astype(int)                #new color is the weighted sum over the total, make sure it is a whole number for rbg vale

    #mutation section, want mutation to artifically change "frequecy" or "fitness" (either positive or negative) and also change color
    #inspired by github, account for mutation, the RBG value and "density" or relative fitness will be mutilplied by beneficial or detriment factor to change color slighlty and either raise or lower fitness/frequency artifically
    if np.random.rand() < mutation_rate:
      if np.random.rand() < 0.10:                                                  #10% chance of being good mutation, 90% chance of being bad (idk if that biologocally accurate)
        mutation = np.clip(w_average_color * beneficial_mutation_multiplier, 0, 255).astype(int)
        density_adjustment_factor = beneficial_mutation_multiplier
      else:
        mutation = np.clip(w_average_color * detrimental_mutation_multiplier, 0, 255).astype(int)
        density_adjustment_factor = detrimental_mutation_multiplier
      new_color = tuple(mutation)

      total_density *= density_adjustment_factor

    else:
      new_color = tuple(w_average_color)

  else:
    new_color = (0,0,0)                                                         #dead cell if no live neighbors

  return new_color                                                              #return color for gen step

"""# Setting up Base Game Parameters and calling Fitness f(x) for Color Determination
#COMPLETE DUE APRIL 15, 2024

## grid_update( genx-1_grid, color_update, rule=[[3],[2,3]])
  **Purpose:** This function is "updates" the initalized random grid based off rules for the next iteration or generation". The def takes the arguments of the previous generations grid, rules to update the color(fitness), and the rules for conways game.

Geek for Geek's Bulk of Game Rules (Took some bits from this code as well)

NOTES: I like the way the grid here is constructed more so than the Colorful GOL.

    def update(frameNum, img, grid, N):
      
        # copy grid since we require 8 neighbors  
        # for calculation and we go line by line  
        newGrid = grid.copy()
        for i in range(N):
            for j in range(N):
      
                # compute 8-neighbor sum
                # using toroidal boundary conditions - x and y wrap around  
                # so that the simulation takes place on a toroidal surface.
                total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +
                            grid[(i-1)%N, j] + grid[(i+1)%N, j] +
                            grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +
                            grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)
      
                # apply Conway's rules
                if grid[i, j]  == ON:
                    if (total < 2) or (total > 3):
                        newGrid[i, j] = OFF
                else:
                    if total == 3:
                        newGrid[i, j] = ON
      
        # update data
        img.set_data(newGrid)
        grid[:] = newGrid[:]
        return img,

Colorful GOL Git Hub (Mostly editted this peice of code to work for our purposes)  https://github.com/adam-zheleznyak/colorful-life/blob/master/examples.py Why does he have the rules 3 different times?

    def colorful_life_step(colored_grid, color_variation=0.05, hard_boundary=True, rule=[[3],[2,3]]):
      '''
      Runs a step for The Colorful Game of Life.
      
      The Colorful Game of Life has the same rules as Conway's Game of Life, except that all living cells also have a color assigned to them. When a new cell is born, it will take on the average color of its parents. Color variation can be added so that newly born cells can deviate slightly in color. Living cells will keep their color fixed until they die.
      
      Parameters:
      colored_grid (2D list of Hue objects): The grid that should be stepped through
      color_variation (float): A newly born cell will deviate from its color randomly up or down, with this amount being the maximum possible deviation.
      hard_boundary (bool): Setting this to False will identify opposite edges so that cells touching the boundary will communicate with cells on the other side of the grid.
      rule (2D list of integers): The first set of elements is how many neighbors leads to a birth, and the second is how many neighbors lead to a cell surviving.
      
      Returns:
      2D list of Hue objects
      '''
      
      height = len(colored_grid)
      width = len(colored_grid[0])
      next_grid = []
      if not hard_boundary:
        if width >= 3 and height >= 3:
          for j in range(height):
            row = []
            for i in range(width):
              live_neighbors = [colored_grid[(j+a) % height][(i+b) % width] for a in (-1,0,1) for b in (-1,0,1) if ((a is not 0 or b is not 0) and colored_grid[(j+a) % height][(i+b) % width])]
              neighbor_count = len(live_neighbors)
              if colored_grid[j][i]:
                if neighbor_count in rule[1]:
                  row.append(colored_grid[j][i])
                else:
                  row.append(None)
              else:
                if neighbor_count in rule[0]:
                  hue = average_hue(live_neighbors)
                  row.append(Hue(hue.value+uniform(-color_variation, color_variation)))
                else:
                  row.append(None)
            next_grid.append(row)
          return next_grid
        else:
          # Need to tweak things so cells aren't double-counted
          for j in range(height):
            row = []
            for i in range(width):
              if height >= 3:
                # width is short
                live_neighbors = [colored_grid[(j+a) % height][(i+b) % width] for a in (-1,0,1) for b in range(width) if ((a is not 0 or b is not 0) and colored_grid[(j+a) % height][(i+b) % width])]
              elif width >= 3:
                # height is short
                live_neighbors = [colored_grid[(j+a) % height][(i+b) % width] for a in range(height) for b in (-1,0,1) if ((a is not 0 or b is not 0) and colored_grid[(j+a) % height][(i+b) % width])]
              else:
                # width and height are short
                live_neighbors = [colored_grid[(j+a) % height][(i+b) % width] for a in range(height) for b in range(width) if ((a is not 0 or b is not 0) and colored_grid[(j+a) % height][(i+b) % width])]
                
                
              neighbor_count = len(live_neighbors)
              if colored_grid[j][i]:
                if neighbor_count in rule[1]:
                  row.append(colored_grid[j][i])
                else:
                  row.append(None)
              else:
                if neighbor_count in rule[0]:
                  hue = average_hue(live_neighbors)
                  row.append(Hue(hue.value+uniform(-color_variation, color_variation)))
                else:
                  row.append(None)
            next_grid.append(row)
          return next_grid
      else:
        for j in range(height):
          row = []
          for i in range(width):
            live_neighbors = [colored_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if ((a is not 0 or b is not 0) and ((j+a) % height is j+a) and ((i+b) % width is i+b) and colored_grid[j+a][i+b])]
            neighbor_count = len(live_neighbors)
            if colored_grid[j][i]:
              if neighbor_count in rule[1]:
                row.append(colored_grid[j][i])
              else:
                row.append(None)
            else:
              if neighbor_count in rule[0]:
                hue = average_hue(live_neighbors)
                row.append(Hue(hue.value+uniform(-color_variation, color_variation)))
              else:
                row.append(None)
          next_grid.append(row)
        return next_grid

![image.png](data:image/png;base64,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)
"""

#Steps into the next generation, color changes based on fitness, and cells changed based of conways rules
#Im not sure why Colorful GOL had the rules 3 times, but going to just roll with the base.
def generation_step(user_grid, color_denisty_map, color_variation=0.05, survival_rule=[2, 3], birth_rule=[3],):
  height , width = user_grid.shape[:2] #based on first user_grid find # elements in row/column
  next_grid = np.zeros((height, width, 3), dtype=np.uint8) #initilaize next grid as black and will update with rules as follows, dtype=np.uint8 is used for uint8: 8-bit unsigned integer (0 to 255). Most often this is used for arrays representing images, with the 3 color channels having small integer values (0 to 255)

  if width >= 3 and height >= 3: #Will error out if the enviroment or the size of the grid is less than 3x3 (for ease of Conway's Rules)
    #iterate through each cell
    for j in range(height):
      for i in range(width):

        #here "a" represents the current cell (0), to above(-1), and below(1) the cell being iterated on. "b" represents the current, left(-1), and right(+1) of cell being iterated on.
        #check all 8 surrounding cells, I dont want torodial because I want boundries, so got rid of it from Github version. If organism leaves boudries, it is "dead". NOTE! cells on edges have differnt odds of survival then.

        live_neighbors = [user_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if (a != 0 or b != 0) and (0 <= j+a < height) and (0 <= i+b < width) and np.any(user_grid[j+a][i+b] > 0)]
                                                #exclude current cell, check if neighboring cells is within the boundries, check if neighboring cell is alive, any RGB value is non-zero
        neighbor_count = len(live_neighbors)  #from LC above, count how many cells around iterated cell were alive or "1"


        if np.any(user_grid[j][i]>0): #If current cell is alive
          if neighbor_count in survival_rule: #If has enough alive neighbors (i.e 2 or 3 in rule[1] = [2,3])
            next_grid[j,i] =user_grid[j,i] #cell from user grid survives and makes it to next gen
          else:
            next_grid[j,i] = (0,0,0) #append a dead cell


        else:
          if neighbor_count in birth_rule: #if current cell is dead check to see if it has enough live neighbors to become alive (ie exactly 3 neigbors)
            new_color = fitness_function(live_neigbors, color_density_map)#assign a new color based on fitness
            next_grid[j, i] = new_color

  return next_grid

"""# Setting up the Iterations and saving GIF/Animation

#COMPLETE DUE APRIL 30th
"""

#RIPPED AND EDITED FORM COLORFUL GOL

	def animate(user_grid):
		plt.cla()
		ax.imshow(grid_to_array(user_grid), cmap=plt.cm.hsv, norm=clrs.Normalize(vmin=0,vmax=1), interpolation='nearest')

	anim = anm.FuncAnimation(fig, animate, frames=frames, interval=interval)

	if show:
		plt.show()

	return anim

def save_as_gif(user_grid, number_of_frames, filename, color_density_map, color_variation=0.05, survival_rule=[2, 3], birth_rule=[3], cell_size=0.2, interval=300):
    anim = generation_step_limited(user_grid, number_of_frames, color_density_map, color_variation, survival_rule, birth_rule, interval, cell_size, show=False)
    anim.save(filename, writer='imagemagick', fps=5)
    plt.close()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

def simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, filename, survival_rule=[2, 3], birth_rule=[3], interval=300, cell_size=1.0):
    """
    Simulate the grid evolution for a specified number of generations and save the animation as a GIF.

    Parameters:
    - initial_grid: The starting state of the grid.
    - color_density_map: Dictionary mapping colors (alleles) to their initial relative densities.
    - num_generations: Number of generations to simulate.
    - filename: Filename for the output GIF.
    - survival_rule, birth_rule: Rules determining cell survival and birth.
    - interval: Time interval between frames in the animation.
    - cell_size: Size of each cell in the animation.
    """

    # Prepare the plot
    fig, ax = plt.subplots(figsize=(initial_grid.shape[1]*cell_size, initial_grid.shape[0]*cell_size))
    ax.axis('off')

    grids = [initial_grid]  # List to hold each generation's grid state

    # Simulate each generation
    for _ in range(num_generations):
        next_grid = generation_step(grids[-1], color_density_map, survival_rule=survival_rule, birth_rule=birth_rule)
        color_density_map = color_density_map_update(next_grid)  # Update allele frequencies
        grids.append(next_grid)

    # Animation function
    def update(frame):
        ax.clear()
        ax.axis('off')
        ax.imshow(grids[frame])

    # Create and save the animation
    ani = animation.FuncAnimation(fig, update, frames=num_generations + 1, interval=interval)
    ani.save(filename, writer='imagemagick', fps=10)
    plt.close(fig)

"""#Composite Code VERSION 1"""

import math
from random import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

####################################### INITIALIZATION ###########################################################################################################

def input_colors_and_densities(alleles):
  color_density_map = {}                                                        # Use a dictionary to map colors to densities, useful later for fitness calculations and when updating across gens
  for i in range(alleles):
    rgb_values = input("Choose a color for allele " + str(i+1) + " in RGB format (r,g,b where each value is between 0-255): ")
    rgb_values = rgb_values.split(',')                                          # Expecting user to input format as 'r,g,b'
    color = tuple(map(int, rgb_values))                                         # Convert input to a tuple of integers using HOF and map to


    density = float(input("Enter the relative frequency of allele " + str(i+1) + " (value between 0 and 1): "))
    color_density_map[color] = density                                          #Map color to density
  print(color_density_map)                                                      #check to see what it looks like
  return color_density_map

def random_grid(height, width, overall_density, color_density_map):
  grid = np.zeros((height, width, 3), dtype=np.uint8)                           #learned .uint8 is used spec. for RGB values! Initialize a "dead" grid, each cell with 3 RGB # assocaited with it
  colors = list(color_density_map.keys())                                       #list all the colors from input
  densities = list(color_density_map.values())                                  #list the allele freq from input
  for i in range(height):
    for j in range(width):
      if np.random.rand() < overall_density:                                    # Decide if the cell is alive or a "1" by generating a number between 0-1. If # < overall_denisty or the organisms population density, its alive! Life...uh, finds a way.
        color_index = np.random.choice(len(colors), p=densities)                #assign it a random color from input colors and realtive allele freq.
        grid[i, j] = colors[color_index]

  return grid


# All the user inputs for grid dimensions and overall population density
height = int(input("Enter the environment's height: "))
width = int(input("Enter the environment's width: "))
overall_density = float(input("Enter the organisms population density (value between 0 and 1): "))

# All the input for specific colors to alleles and their relative densities in population
alleles = int(input("Enter the number of alleles in population: "))
color_density_map = input_colors_and_densities(alleles)

# Call random_grid to generate the grid with the user-defined parameters
user_grid = random_grid(height, width, overall_density, color_density_map)
plt.imshow(user_grid)
plt.show()                                                                      #generate starting plot so we have something nice to look at while GIF is loading

############################################### FITNESS CALC #########################################################################################################

#used to update the color_denisty_map based on current generation, will impliment later
def color_density_map_update(grid):
  color_denisity_update = {}                                                    #empty dict to store all new + old colors that may have been "born"
  total_alive = 0                                                               #number of cells alive for realtive density
  for row in grid:
    for cell in row:
      if np.any(cell > 0):                                                      #check if alive if have rgb info
        cell_color = tuple(cell)                                                #have to turn to tuple so I can make keys for dict and search later.
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        total_alive += 1                                                         #add cell alive count

 # After counting all cells, calculate the relative density for each color/allele by dividing its count by the total number of alive cells. Going to use dictionary comprehension

  color_density_map_update = {color: count/ total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

#If you have a higher relative denisty in the population, the higher your fitness or ability to pass gene to offspring. Colors/Alleles with higher relative densities have a greater influence on the resulting color.
#Hybrids have bad realtive density though, so equals to bad fitness. In above color_denisty_update maybe have it be a very small chance that one cell if lucky and hybrid artifically has a high fitness "high-density" to equal a advantagous allele/mutation

def fitness_function(live_neighbors, color_density_map):
  # Initialize weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0]) #cumulative RGB values of neighbor livecells
  total_density = 0.0 #used to calc weighted average later

  # Calculate weighted sums for each color component
  for color in live_neighbors:                                                   #iterate over color/rbg values. this is implimented in the gen_step function, because have to be detrmined by rules as well.
    n_color = tuple(color)                                                       #have to turn to tuple to extract and use dictionary keys. *rememeber tuples immutable so can be used as keys
    if n_color in color_density_map:                                             #does color exist in dictionary
      density = color_density_map[n_color]                                       #if so get the density/relative frequency
      weighted_sum += np.array(color) * density                                  #multiply the color by the density giving it more weight, and add to weighted sum. turn back to array
      total_density += density                                                   #add density to total

  if total_density > 0:
    new_color = (weighted_sum / total_density).astype(int) #new color is the weighted sum over the total, make sure it is a whole number for rbg vale
  else:
    new_color = (0,0,0)                                                         #dead cell if no live neighbors

  return tuple(new_color)                                                       #return color for gen step

################################################## GENERATION STEPS ############################################################################

def generation_step(user_grid, color_denisty_map, color_variation=0.05, survival_rule=[2, 3], birth_rule=[3],):
  height , width = user_grid.shape[:2]                                          #based on first user_grid find # elements in row/column
  next_grid = np.zeros((height, width, 3), dtype=np.uint8)                      #initilaize next grid as dead like in intilization and will update grid with cells based on the rules as follows

  if width >= 3 and height >= 3:                                                #Will error out if the enviroment or the size of the grid is less than 3x3 (for ease of Conway's Rules)
    #iterate through each cell
    for j in range(height):
      for i in range(width):

        #ripped from GitHub version, here "a" represents the current cell (0), to above(-1), and below(1) the cell being iterated on. "b" represents the current, left(-1), and right(+1) of cell being iterated on.
        #NOTE: IDK WHY THE GIHUB VERSION HAD THE RULES IN THE LOOP 3 SEPERATE TIMES (TO PREVENT DOUBLE COUNTING MAYBE?), I GOT RID OF IT BECAUSE a.) MY RAM and b.) I DONT THINK NEEDED
        #check all 8 surrounding cells, I dont want torodial because I want the boundries, so got rid of it from Github version as well. If organism leaves boudries, it is "dead". NOTE! cells on edges have differnt odds of survival then, but organimsm not in there habitat will die and edge of habitat have greater odds of dying, so well justify it like that hehe.

        live_neighbors = [user_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if (a != 0 or b != 0) and (0 <= j+a < height) and (0 <= i+b < width) and np.any(user_grid[j+a][i+b] > 0)]
                                                #conditionals: exclude current cell, check if neighboring cells is within the boundries, check if neighboring cell is alive, any RGB value is non-zero or alive/has color

        neighbor_count = len(live_neighbors)                                    #from LC above, count how many cells around iterated cell were alive or have RGB values


        if np.any(user_grid[j][i]>0):                                           #If current cell is alive
          if neighbor_count in survival_rule:                                   # and If has enough alive neighbors (i.e 2 or 3)
            next_grid[j,i] =user_grid[j,i]                                      #cell from user grid survives and makes it to next gen
          else:
            next_grid[j,i] = (0,0,0)                                            #append a dead cell, you lost the game of life, no one to mate with (underpopulation) or you were too ugly to mate with (overpopulated) *sad trumpet*


        else:
          if neighbor_count in birth_rule:                                      #if current cell is dead check to see if it has enough live neighbors to frankenstien alive (ie has exactly 3 neigbors)
            new_color = fitness_function(live_neighbors, color_density_map)     #assign a new color based on fitness function above (weighted mean, you get more of the better genes from one of your parents and a little of the bad genes from te other)
            next_grid[j, i] = new_color

  return next_grid

##################################################### LIMITED GEN + SAVE AS GIF ##############################################

#Ripped from github version but tweaked to include the color_density_map updates per iteration.

def simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, filename, survival_rule=[2, 3], birth_rule=[3], interval=500, cell_size=1.0):
  fig, ax = plt.subplots(figsize=(initial_grid.shape[1]*cell_size, initial_grid.shape[0]*cell_size))
  ax.axis('off')
  grids = [initial_grid]                                                        # List to hold each generation's grid state

  for _ in range(num_generations):
    next_grid = generation_step(grids[-1], color_density_map, survival_rule=survival_rule, birth_rule=birth_rule)
    color_density_map = color_density_map_update(next_grid)                     # Update allele frequencies per gen
    grids.append(next_grid)

  # Animation function ripped from github
  def update(frame):
    ax.clear()
    ax.axis('off')
    ax.imshow(grids[frame])

  # Create and save the animation ripped from github
  ani = animation.FuncAnimation(fig, update, frames=num_generations + 1, interval=interval)
  ani.save(filename, writer='imagemagick', fps=5)
  plt.close(fig)

#CAN EDIT FPS AND INTERVAL TO TOGGLE GIF OUTPUT (SPEED AND NUMBER OF FRAMES PER MILLISECOND(?), TOGGLE ITERATIONS BELOW
initial_grid = user_grid
num_generations = int(input("How many generations of population?"))
simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, 'genedrifter.gif')

"""# Comopsite Code VERSION 2-

* ADDED MUTATIONS (multipier) INTO THE FITNESS() FUNCTION
"""

import math
from random import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

####################################### INITIALIZATION ###########################################################################################################

def input_colors_and_densities(alleles):
  color_density_map = {}                                                        # Use a dictionary to map colors to densities, useful later for fitness calculations and when updating across gens
  for i in range(alleles):
    rgb_values = input("Choose a color for allele " + str(i+1) + " in RGB format (r,g,b where each value is between 0-255): ")
    rgb_values = rgb_values.split(',')                                          # Expecting user to input format as 'r,g,b'
    color = tuple(map(int, rgb_values))                                         # Convert input to a tuple of integers using HOF and map to


    density = float(input("Enter the relative frequency of allele " + str(i+1) + " (value between 0 and 1): "))
    color_density_map[color] = density                                          #Map color to density
  print(color_density_map)                                                      #check to see what it looks like
  return color_density_map

def random_grid(height, width, overall_density, color_density_map):
  grid = np.zeros((height, width, 3), dtype=np.uint8)                           #learned .uint8 is used spec. for RGB values! Initialize a "dead" grid, each cell with 3 RGB # assocaited with it
  colors = list(color_density_map.keys())                                       #list all the colors from input
  densities = list(color_density_map.values())                                  #list the allele freq from input
  for i in range(height):
    for j in range(width):
      if np.random.rand() < overall_density:                                    # Decide if the cell is alive or a "1" by generating a number between 0-1. If # < overall_denisty or the organisms population density, its alive! Life...uh, finds a way.
        color_index = np.random.choice(len(colors), p=densities)                #assign it a random color from input colors and realtive allele freq.
        grid[i, j] = colors[color_index]

  return grid


# All the user inputs for grid dimensions and overall population density
height = int(input("Enter the environment's height: "))
width = int(input("Enter the environment's width: "))
overall_density = float(input("Enter the organisms population density (value between 0 and 1): "))

# All the input for specific colors to alleles and their relative densities in population
alleles = int(input("Enter the number of alleles in population: "))
color_density_map = input_colors_and_densities(alleles)

# Call random_grid to generate the grid with the user-defined parameters
user_grid = random_grid(height, width, overall_density, color_density_map)
plt.imshow(user_grid)
plt.show()                                                                      #generate starting plot so we have something nice to look at while GIF is loading

############################################### FITNESS CALC #########################################################################################################

#used to update the color_denisty_map based on current generation, will impliment later
def color_density_map_update(grid):
  color_denisity_update = {}                                                    #empty dict to store all new + old colors that may have been "born"
  total_alive = 0                                                               #number of cells alive for realtive density
  for row in grid:
    for cell in row:
      if np.any(cell > 0):                                                      #check if alive if have rgb info
        cell_color = tuple(cell)                                                #have to turn to tuple so I can make keys for dict and search later.
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        total_alive += 1                                                         #add cell alive count

 # After counting all cells, calculate the relative density for each color/allele by dividing its count by the total number of alive cells. Going to use dictionary comprehension

  color_density_map_update = {color: count/ total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

#If you have a higher relative denisty in the population, the higher your fitness or ability to pass gene to offspring. Colors/Alleles with higher relative densities have a greater influence on the resulting color.
#Hybrids have bad realtive density though, so equals to bad fitness. In above color_denisty_update maybe have it be a very small chance that one cell if lucky and hybrid artifically has a high fitness "high-density" to equal a advantagous allele/mutation

def fitness_function(live_neighbors, color_density_map, mutation_rate=0.01, beneficial_mutation_multiplier = 1.25, detrimental_mutation_multiplier = 0.8): #picked multiplier and mutation rate arbutrarily
  # Initialize weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0]) #cumulative RGB values of neighbor livecells
  total_density = 0.0 #used to calc weighted average later

  # Calculate weighted sums for each color component
  for color in live_neighbors:                                                   #iterate over color/rbg values. this is implimented in the gen_step function, because have to be detrmined by rules as well.
    n_color = tuple(color)                                                       #have to turn to tuple to extract and use dictionary keys. *rememeber tuples immutable so can be used as keys
    if n_color in color_density_map:                                             #does color exist in dictionary
      density = color_density_map[n_color]                                       #if so get the density/relative frequency
      weighted_sum += np.array(color) * density                                  #multiply the color by the density giving it more weight, and add to weighted sum. turn back to array
      total_density += density                                                   #add density to total

  if total_density > 0:
    w_average_color = (weighted_sum / total_density).astype(int)                #new color is the weighted sum over the total, make sure it is a whole number for rbg vale

    #mutation section, want mutation to artifically change "frequecy" or "fitness" (either positive or negative) and also change color
    #inspired by github, account for mutation, the RBG value and "density" or relative fitness will be mutilplied by beneficial or detriment factor to change color slighlty and either raise or lower fitness/frequency artifically
    if np.random.rand() < mutation_rate:
      if np.random.rand() < 0.10:                                                  #10% chance of being good mutation, 90% chance of being bad (idk if that biologocally accurate)
        mutation = np.clip(w_average_color * beneficial_mutation_multiplier, 0, 255).astype(int) #using np.clip so # isnt out of rgb "bounds" https://numpy.org/doc/stable/reference/generated/numpy.clip.html
        density_adjustment_factor = beneficial_mutation_boost
        density_adjustment_factor = beneficial_mutation_multiplier
      else:
        mutation = np.clip(w_average_color * detrimental_mutation_multiplier, 0, 255).astype(int)
        density_adjustment_factor = detrimental_mutation_multiplier
      new_color = tuple(mutation)

      total_density *= density_adjustment_factor

    else:
      new_color = tuple(w_average_color)

  else:
    new_color = (0,0,0)                                                         #dead cell if no live neighbors

  return new_color                                                              #return color for gen step

################################################## GENERATION STEPS ############################################################################

def generation_step(user_grid, color_denisty_map, survival_rule=[2, 3], birth_rule=[3],):
  height , width = user_grid.shape[:2]                                          #based on first user_grid find # elements in row/column
  next_grid = np.zeros((height, width, 3), dtype=np.uint8)                      #initilaize next grid as dead like in intilization and will update grid with cells based on the rules as follows

  if width >= 3 and height >= 3:                                                #Will error out if the enviroment or the size of the grid is less than 3x3 (for ease of Conway's Rules)
    #iterate through each cell
    for j in range(height):
      for i in range(width):

        #ripped from GitHub version, here "a" represents the current cell (0), to above(-1), and below(1) the cell being iterated on. "b" represents the current, left(-1), and right(+1) of cell being iterated on.
        #NOTE: IDK WHY THE GIHUB VERSION HAD THE RULES IN THE LOOP 3 SEPERATE TIMES (TO PREVENT DOUBLE COUNTING MAYBE?), I GOT RID OF IT BECAUSE a.) MY RAM and b.) I DONT THINK NEEDED
        #check all 8 surrounding cells, I dont want torodial because I want the boundries, so got rid of it from Github version as well. If organism leaves boudries, it is "dead". NOTE! cells on edges have differnt odds of survival then, but organimsm not in there habitat will die and edge of habitat have greater odds of dying, so well justify it like that hehe.

        live_neighbors = [user_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if (a != 0 or b != 0) and (0 <= j+a < height) and (0 <= i+b < width) and np.any(user_grid[j+a][i+b] > 0)]
                                                #conditionals: exclude current cell, check if neighboring cells is within the boundries, check if neighboring cell is alive, any RGB value is non-zero or alive/has color

        neighbor_count = len(live_neighbors)                                    #from LC above, count how many cells around iterated cell were alive or have RGB values


        if np.any(user_grid[j][i]>0):                                           #If current cell is alive
          if neighbor_count in survival_rule:                                   # and If has enough alive neighbors (i.e 2 or 3)
            next_grid[j,i] =user_grid[j,i]                                      #cell from user grid survives and makes it to next gen
          else:
            next_grid[j,i] = (0,0,0)                                            #append a dead cell, you lost the game of life, no one to mate with (underpopulation) or you were too ugly to mate with (overpopulated) *sad trumpet*


        else:
          if neighbor_count in birth_rule:                                      #if current cell is dead check to see if it has enough live neighbors to frankenstien alive (ie has exactly 3 neigbors)
            new_color = fitness_function(live_neighbors, color_density_map)     #assign a new color based on fitness function above (weighted mean, you get more of the better genes from one of your parents and a little of the bad genes from te other)
            next_grid[j, i] = new_color

  return next_grid

##################################################### LIMITED GEN + SAVE AS GIF ##############################################

#Ripped from github version but tweaked to include the color_density_map updates per iteration.

def simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, filename, survival_rule=[2, 3], birth_rule=[3], interval=500, cell_size=1.0):
  fig, ax = plt.subplots(figsize=(initial_grid.shape[1]*cell_size, initial_grid.shape[0]*cell_size))
  ax.axis('off')
  grids = [initial_grid]                                                        # List to hold each generation's grid state

  for _ in range(num_generations):
    next_grid = generation_step(grids[-1], color_density_map, survival_rule=survival_rule, birth_rule=birth_rule)
    color_density_map = color_density_map_update(next_grid)                     # Update allele frequencies per gen
    grids.append(next_grid)

  # Animation function ripped from github
  def update(frame):
    ax.clear()
    ax.axis('off')
    ax.imshow(grids[frame])

  # Create and save the animation ripped from github
  ani = animation.FuncAnimation(fig, update, frames=num_generations + 1, interval=interval)
  ani.save(filename, writer='imagemagick', fps=5)
  plt.close(fig)

#CAN EDIT FPS AND INTERVAL TO TOGGLE GIF OUTPUT (SPEED AND NUMBER OF FRAMES PER MILLISECOND(?), TOGGLE ITERATIONS BELOW
initial_grid = user_grid
num_generations = int(input("How many generations of population?"))
simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, 'genedrifter.gif')

"""#Composite Code VERSION 3  

* REFACTORED SO PROBABILTIES ALWAYS EQUAL 1 FOR RELATIVE FREQUENCY IN INPUT_COLOR_DENSITY() FUNTION

"""

import math
from random import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

####################################### INITIALIZATION ###########################################################################################################

#Need to fix this so probabilities alwayys equal to 1
def input_colors_and_densities(alleles):
  color_density_map = {}                                                        # Use a dictionary to map colors to densities, useful later for fitness calculations and when updating across gens
  total_density = 0
  for i in range(alleles-1):                                                   #Edit, all but the last allele entered
    rgb_values = input("Choose a color for allele " + str(i+1) + " in RGB format (r,g,b where each value is between 0-255): ").split(',') # Expecting the user to input format as 'r,g,b'.This could be error prone...but I like the freedom to pick color
    color = tuple(map(int, rgb_values))                                         # Convert input to a tuple of integers using HOF and map to. Dictionries require keys that are immutable

    density = float(input("Enter the relative frequency of allele " + str(i+1) + " (value between 0 and 1): "))
    color_density_map[color] = density                                          #Map the input color(list of tuples) to density
    total_density += density

  # Not a great fix, but I dont want the error to happen where probabilites dont sum to 1. For the last allele needed so we can adjust the density to ensure the sum is exactly 1
  rgb_values = input("Choose a color for allele " + str(alleles) + " in RGB format (r,g,b).:").split(',')
  color = tuple(map(int, rgb_values))
  remaining_density = 1 - total_density
  print("The relative frequency for allele " + str(alleles) + " is set to " + str(remaining_density) + " to ensure sum equals 1.")
  color_density_map[color] = remaining_density

  print(color_density_map)                                                      #check to see what it looks like
  return color_density_map

def random_grid(height, width, overall_density, color_density_map):
  grid = np.zeros((height, width, 3), dtype=np.uint8)                           #learned .uint8 is used specific for RGB values. Initialize a "dead" grid, each cell with 3 RGB # assocaited with it
  colors = list(color_density_map.keys())                                       #make a list all the colors from input
  densities = list(color_density_map.values())                                  #make a list the allele freq from input
  for i in range(height):
    for j in range(width):
      if np.random.rand() < overall_density:                                    # Decide if the cell is alive or a "1" by generating a number between 0-1. If # < overall_denisty or the organisms population density, its alive! Life...uh, finds a way.
        color_index = np.random.choice(len(colors), p=densities)                #assign it a random color from input colors and realtive allele freq.
        grid[i, j] = colors[color_index]

  return grid


# All the user inputs for grid dimensions and overall population density
height = int(input("Enter the environment's height: "))
width = int(input("Enter the environment's width: "))
overall_density = float(input("Enter the organisms population density (value between 0 and 1): "))

# All the input for specific colors to alleles and their relative densities in population
alleles = int(input("Enter the number of alleles in population: "))
color_density_map = input_colors_and_densities(alleles)

# Call random_grid to generate the grid with the user-defined parameters
user_grid = random_grid(height, width, overall_density, color_density_map)
plt.imshow(user_grid)
plt.show()                                                                      #generate starting plot so we have something nice to look at while GIF is loading

############################################### FITNESS CALC #########################################################################################################

#used to update the color_denisty_map based on current generation, will call on this later in generation/iterative step
def color_density_map_update(grid):
  color_denisity_update = {}                                                    #empty dict to store all new + old colors that may have been "born" from old one
  total_alive = 0                                                               #number of cells alive for calculating realtive density
  for row in grid:
    for cell in row:
      if np.any(cell > 0):                                                      #check if alive (ie if they have rgb info/color)
        cell_color = tuple(cell)                                                #have to turn to tuple so I can make keys for dict and search later.
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        total_alive += 1                                                         #add cell alive count

 # After counting all cells, calculate the relative density for each color/allele by dividing its count by the total number of alive cells. Going to use dictionary comprehension
  color_density_map_update = {color: count/total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

#One thing to note, hybrids have bad fitness since there is very bad realive frequency of them...might have to help them out a bit...

#Fitness:If you have a higher relative denisty in the population, the higher your fitness or ability to pass gene to offspring. Colors/Alleles with higher relative densities have a greater influence on the resulting color.
#Mutation: THere is a small chance the color assigned will be a result of a good or bad mutation. If that small chance happens, the fitness score will be (+) or (-) and the RBG values will also change by that amount. (might change to add random color maybe to be more exciting, because right now just changes same color by +/- some number)
#CHANGE MUTATION RATE AND PENALTY/BOOST TO MATCH REAL LIFE HERE OTHERWISE FIXED

def fitness_function(live_neighbors, color_density_map, mutation_rate=0.01, beneficial_mutation_boost = 4, detrimental_mutation_penalty = -4): #picked multiplier and mutation rate arbutrarily
  # Initialize weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0])                                        #cumulative RGB values of neighbor live cells
  total_density = 0.0                                                           #used to calc weighted average later
  densities = {}
  # Calculate weighted sums for each color component
  for color in live_neighbors:                                                   #iterate over color/rbg values. this is implimented in the gen_step function, because have to be detrmined by rules as well.
    n_color = tuple(color)                                                       #have to turn to tuple to extract and use dictionary keys. *rememeber tuples immutable so can be used as keys
    if n_color in color_density_map:                                             #does color exist in dictionary
      density = color_density_map[n_color]                                       #if so get the density/relative frequency
      weighted_sum += np.array(color) * density                                  #multiply the color by the density giving it more weight, and add to weighted sum. turn back to array
      total_density += density                                                   #add density to total
      densities[n_color] = density                                              # store original densities
  if total_density > 0:
    w_average_color = (weighted_sum / total_density).astype(int)                #new color is the weighted sum over the total, make sure it is a whole number for rbg vale

    #MUTATION SECTION , want mutation to artifically change "frequecy" or "fitness" (either positive or negative). Limitation to this, if user choosse a max/min of value, you might not see effect since cliped at 0 and 255.
    if np.random.rand() < mutation_rate:
      if np.random.rand() < 0.10:                                               #CAN CHANGE THIS: 10% chance of being good mutation, 90% chance of being bad (idk if that biologocally accurate, but most mutations are deleterious)
        new_color = (0,255,0)                                                   #green
        mutation_factor = beneficial_mutation_boost

      else:
        new_color = (150,200,0)                                                  #yellow
        mutation_factor = detrimental_mutation_penalty

      for new_color in densities:
        densities[new_color] *= mutation_factor

      total_density = sum(densities.values())
    else:
      new_color = tuple(w_average_color)

  else:
    new_color = (0,0,0)                                                         #dead cell if no live neighbors

  return new_color                                                              #return color for gen step

################################################## GENERATION STEPS ############################################################################

def generation_step(user_grid, color_denisty_map, survival_rule=[2, 3], birth_rule=[3],):
  height , width = user_grid.shape[:2]                                          #based on first user_grid find # elements in row/column
  next_grid = np.zeros((height, width, 3), dtype=np.uint8)                      #initilaize next grid as dead like in intilization and will update grid with cells based on the rules as follows

  if width >= 3 and height >= 3:                                                #Will error out if the enviroment or the size of the grid is less than 3x3 (for ease of Conway's Rules)
    #iterate through each cell
    for j in range(height):
      for i in range(width):

        #ripped from GitHub version, here "a" represents the current cell (0), to above(-1), and below(1) the cell being iterated on. "b" represents the current, left(-1), and right(+1) of cell being iterated on.
        #NOTE: IDK WHY THE GIHUB VERSION HAD THE RULES IN THE LOOP 3 SEPERATE TIMES (TO PREVENT DOUBLE COUNTING MAYBE?), I GOT RID OF IT BECAUSE a.) MY RAM and b.) I DONT THINK NEEDED
        #check all 8 surrounding cells, I dont want torodial because I want the boundries, so got rid of it from Github version as well. If organism leaves boudries, it is "dead". NOTE! cells on edges have differnt odds of survival then, but organimsm not in there habitat will die and edge of habitat have greater odds of dying, so well justify it like that hehe.

        live_neighbors = [user_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if (a != 0 or b != 0) and (0 <= j+a < height) and (0 <= i+b < width) and np.any(user_grid[j+a][i+b] > 0)]
                                                #conditionals: exclude current cell, check if neighboring cells is within the boundries, check if neighboring cell is alive, any RGB value is non-zero or alive/has color

        neighbor_count = len(live_neighbors)                                    #from LC above, count how many cells around iterated cell were alive or have RGB values


        if np.any(user_grid[j][i]>0):                                           #If current cell is alive
          if neighbor_count in survival_rule:                                   # and If has enough alive neighbors (i.e 2 or 3)
            next_grid[j,i] =user_grid[j,i]                                      #cell from user grid survives and makes it to next gen
          else:
            next_grid[j,i] = (0,0,0)                                            #append a dead cell, you lost the game of life, no one to mate with (underpopulation) or you were too ugly to mate with (overpopulated) *sad trumpet*


        else:
          if neighbor_count in birth_rule:                                      #if current cell is dead check to see if it has enough live neighbors to frankenstien alive (ie has exactly 3 neigbors)
            new_color = fitness_function(live_neighbors, color_density_map)     #assign a new color based on fitness function above (weighted mean, you get more of the better genes from one of your parents and a little of the bad genes from te other)
            next_grid[j, i] = new_color

  return next_grid

##################################################### LIMITED GEN + SAVE AS GIF ##############################################
#Ripped from github version but tweaked to include the color_density_map updates per iteration and put it all into 1 big function instead of two seperate

def simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, filename, survival_rule=[2, 3], birth_rule=[3], interval=800, cell_size=1.0):
  fig, ax = plt.subplots(figsize=(initial_grid.shape[1]*cell_size, initial_grid.shape[0]*cell_size + 2))
  ax.axis('off')
  grids = [initial_grid]                                                        # List to hold each generation's grid state

  for _ in range(num_generations):
    next_grid = generation_step(grids[-1], color_density_map, survival_rule=survival_rule, birth_rule=birth_rule)
    color_density_map = color_density_map_update(next_grid)                     # Update allele frequencies per gen
    grids.append(next_grid)

  # Animation function ripped from github
  def update(frame):
    ax.clear()
    ax.axis('off')
    ax.imshow(grids[frame], extent=[0, initial_grid.shape[1], 0, initial_grid.shape[0]])

    current_density_map = color_density_map_update(grids[frame])
    sorted_colors = sorted(current_density_map.keys(), key=lambda x: current_density_map[x], reverse=True)  # Sort colors to maintain order
    num_colors = len(sorted_colors)
    text_height_position = 0.02  # Position text at the bottom of the figure
    for idx, color in enumerate(sorted_colors):
      density = current_density_map[color]
      # Create a label for each color that includes its RGB values and density
      label = f'{color}: {density:.2f}'
      text_width_position = (idx + 0.5) / num_colors
      ax.text(text_width_position, text_height_position, label, fontsize=20, color=[c / 255 for c in color], transform=ax.transAxes, ha='center')

  #save the animation as gif ripped from github
  ani = animation.FuncAnimation(fig, update, frames=num_generations + 1, interval=interval)
  ani.save(filename, writer='imagemagick', fps=2)
  plt.close(fig)

#CAN EDIT FPS AND INTERVAL TO TOGGLE GIF OUTPUT (SPEED AND NUMBER OF FRAMES PER MILLISECOND(?), TOGGLE ITERATIONS BELOW
initial_grid = user_grid
#num_generations = int(input("How many generations of population?")) This sometimes works, sometimes doesnt, just going to set it to 80 for now for testing purposes
simulate_generations_and_save_as_gif(initial_grid, color_density_map, 80, 'genedrifter.gif')

"""# Composite Code Version 4 FINAL VERSION ANNOTATED"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd
####################################### INITIALIZATION ###########################################################################################################

#Need to fix this so probabilities alwayys equal to 1
def input_colors_and_densities(alleles):
  color_density_map = {}                                                        # Use a dictionary to map colors to densities, useful later for fitness calculations and when updating across gens
  total_density = 0
  for i in range(alleles-1):                                                    #Edit, all but the last allele entered
    rgb_values = input("Choose a color for allele " + str(i+1) + " in RGB format (r,g,b where each value is between 0-255): ").split(',') # Expecting the user to input format as 'r,g,b'.This could be error prone...but I like the freedom to pick color
    color = tuple(map(int, rgb_values))                                         # Convert input to a tuple of integers using HOF and map to. Dictionries require keys that are immutable

    density = float(input("Enter the relative frequency of allele " + str(i+1) + " (value between 0 and 1): "))
    color_density_map[color] = density                                          #Map the input color(list of tuples) to density
    total_density += density

  # Not a great fix, but I dont want the error to happen where probabilites dont sum to 1. For the last allele needed so we can adjust the density to ensure the sum is exactly 1
  rgb_values = input("Choose a color for allele " + str(alleles) + " in RGB format (r,g,b).:").split(',')
  color = tuple(map(int, rgb_values))
  remaining_density = 1 - total_density
  print("The relative frequency for allele " + str(alleles) + " is set to " + str(remaining_density) + " to ensure sum equals 1.")
  color_density_map[color] = remaining_density

  print(color_density_map)                                                      #check to see what it looks like
  return color_density_map

def random_grid(height, width, overall_density, color_density_map):
  grid = np.zeros((height, width, 3), dtype=np.uint8)                           #learned .uint8 is used specific for RGB values. Initialize a "dead" grid, each cell with 3 RGB # assocaited with it
  colors = list(color_density_map.keys())                                       #make a list all the colors from input
  densities = list(color_density_map.values())                                  #make a list the allele freq from input
  for i in range(height):
    for j in range(width):
      if np.random.rand() < overall_density:                                    # Decide if the cell is alive or a "1" by generating a number between 0-1. If # < overall_denisty or the organisms population density, its alive!
        color_index = np.random.choice(len(colors), p=densities)                #assign it a random color from input colors and realtive allele freq.
        grid[i, j] = colors[color_index]

  return grid


# All the user inputs for grid dimensions and overall population density
height = int(input("Enter the environment's height: "))
width = int(input("Enter the environment's width: "))
overall_density = float(input("Enter the organisms population density (value between 0 and 1): "))

# All the input for specific colors to alleles and their relative densities in population
alleles = int(input("Enter the number of alleles in population: "))
color_density_map = input_colors_and_densities(alleles)

# Call random_grid to generate the grid with the user-defined parameters
user_grid = random_grid(height, width, overall_density, color_density_map)
plt.imshow(user_grid)
plt.show()                                                                      #generate starting plot so we have something nice to look at while GIF is loading

############################################### FITNESS CALC #########################################################################################################

#used to update the color_denisty_map based on current generation, will call on this later in generation/iterative step in Phase 4
def color_density_map_update(grid):
  color_denisity_update = {}                                                    #empty dict to store all new + old colors that may have been "born" from old one
  total_alive = 0                                                               #number of cells alive for calculating realtive density
  for row in grid:
    for cell in row:
      if np.any(cell > 0):                                                      #check if alive (ie if they have rgb info/color)
        cell_color = tuple(cell)                                                #have to turn to tuple so I can make keys for dict and search later.
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1 #Look up the current cell's color in the dicitonary and +1 to # of cell with this color. Assign it back into the dictionary with updated count.
        total_alive += 1                                                         #add cell alive count
#Dictioanry Comp. After counting all cells, calculate the relative density for each color/allele by dividing its count by the total number of alive cells. Going to use dictionary comprehension
  color_density_map_update = {color: count/total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

#One thing to note, hybrids have bad fitness since there is very bad realive frequency of them which is why we give them boosters

#Fitness:If you have a higher relative denisty in the population, the higher your fitness or ability to pass gene to offspring. Colors/Alleles with higher relative densities have a greater influence on the resulting color. Will call this in Phase 3
#Mutation: THere is a small chance the color assigned will be a result of a good or bad mutation. If that small chance happens, the fitness score will be (+) or (-) each time new mutant made or just made and the RBG values will also change by that amount.
#CHANGE MUTATION RATE AND PENALTY/BOOST TO MATCH REAL LIFE HERE OTHERWISE HARD CODED

def fitness_function(live_neighbors, color_density_map, mutation_rate=0.01, beneficial_mutation_boost = 0.3, detrimental_mutation_penalty = -0.3): #picked boost/penalty and mutation rate arbutrarily
  # Initialize weighted sums of RGB values and total
  weighted_sum = np.array([0.0,0.0,0.0])                                        #cumulative RGB values of neighbor live cells
  total_density = 0.0                                                           #used to calc weighted average later
  # Calculate weighted sums for each color component
  for color in live_neighbors:                                                  #iterate over list of parent's color/rbg values. live neighbors is introduced in Phase 3 the gen_step function, because cell that is born has to be detrmined by Conway rules.
    p_color = tuple(color)                                                      # neighbors = p_color or parent (whatever all the same) have to turn to tuple to extract and use dictionary keys in color:denisty. *rememeber tuples immutable so can be used as keys
    if p_color in color_density_map:                                            #does parent color exist in color:denisty dictionary
      density = color_density_map[p_color]                                      #if so extract the density/relative frequency key from dict.
      weighted_sum += np.array(color) * density                                 #multiply the parent color (R,G,B) values by the density giving it more "weight", and add to balnk weighted sum. turn back to array from tuple
      total_density += density                                                  #add parent density to total_density to calc weighted average
  if total_density > 0:
    w_average_color = (weighted_sum / total_density).astype(int)                #new color is the weighted sum over the total, make sure it is a whole number for rbg vale

    #MUTATION SECTION , want mutation to artifically change "frequecy" or "fitness" (either positive or negative). May see some ceilings being hit since RGB = 0 to 255.
    if np.random.rand() < mutation_rate:
      if np.random.rand() < 0.10:                                               #CAN CHANGE THIS: 10% chance of being good mutation, 90% chance of being bad (idk if that biologocally accurate, but most mutations are deleterious)
        new_color = (0,200,0)                                                   #green
        mutation_factor = beneficial_mutation_boost                             #assign factor here --> one thing so we just do one calc later

      else:
        new_color = (250,250,0)                                                 #yellow
        mutation_factor = detrimental_mutation_penalty

      if tuple(new_color) in color_density_map:                                  #conditional used to add new mutant in color_density dictionary (should be added in gen) or if already added adjust rfeq.dist
        color_density_map[tuple(new_color)] = max(0.0, color_density_map[tuple(new_color)] + mutation_factor) #Hey! We've seen this mutation before, but we jsut wanna update the frequency on this go round.
      else:
        color_density_map[tuple(new_color)] = max(0.0, 0.01 + mutation_factor)  # First time seeing a mutation? Great! Add it to the dictionary and give it alittle boster density to start out with or if bad mutant just start with 0.01
    else:
      new_color = tuple(w_average_color)

  else:
    new_color = (0,0,0)                                                         #dead cell if no live neighbors

  return new_color                                                              #return color for gen step

################################################## GENERATION STEPS ############################################################################

def generation_step(user_grid, color_denisty_map, survival_rule=[2, 3], birth_rule=[3],):
  height , width = user_grid.shape[:2]                                          #based on first user_grid find # elements in row/column
  next_grid = np.zeros((height, width, 3), dtype=np.uint8)                      #initilaize next grid as dead like in intilization and will update grid with cells based on the rules as follows

  if width >= 3 and height >= 3:                                                #Will error out if the enviroment or the size of the grid is less than 3x3 (for ease of Conway's Rules)
    #iterate through each cell
    for j in range(height):
      for i in range(width):

        #ripped from GitHub version, here "a" represents the current cell (0), to above(-1), and below(1) the cell being iterated on. "b" represents the current, left(-1), and right(+1) of cell being iterated on.
        #check all 8 surrounding cells, I dont want torodial because I want the boundries, so got rid of it from Github version as well. If organism leaves boudries, it is "dead". NOTE! cells on edges have differnt odds of survival then, but organimsm not in there habitat will die and edge of habitat have greater odds of dying

        live_neighbors = [user_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if (a != 0 or b != 0) and (0 <= j+a < height) and (0 <= i+b < width) and np.any(user_grid[j+a][i+b] > 0)]
                                            #conditionals: exclude current cell, check if neighboring cells is within the boundries, check if neighboring cell is alive, any RGB value is non-zero or alive/has color

        neighbor_count = len(live_neighbors)                                    #from LC above, count how many cells around iterated cell were alive or have RGB values


        if np.any(user_grid[j][i]>0):                                           #If current cell is alive
          if neighbor_count in survival_rule:                                   # and If has enough alive neighbors (i.e 2 or 3)
            next_grid[j,i] = user_grid[j,i]                                      #cell from user grid survives and makes it to next gen
          else:
            next_grid[j,i] = (0,0,0)                                            #append a dead cell, you lost the game of life, no one to mate with (underpopulation) or you were too ugly to mate with (overpopulated) *sad trumpet*


        else:
          if neighbor_count in birth_rule:                                      #if current cell is dead check to see if it has enough live neighbors to frankenstien alive (ie has exactly 3 neigbors)
            new_color = fitness_function(live_neighbors, color_density_map)     #assign a new color based on fitness function above (weighted mean, you get more of the better genes from one of your parents and a little of the bad genes from te other)
            next_grid[j, i] = new_color

  return next_grid

##################################################### LIMITED GEN + SAVE AS GIF ##############################################
#Ripped from github version but tweaked to include the color_density_map updates per iteration and put it all into 1 big function instead of two seperate

def simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, filename, csv_filename, interval=800):
  fig, ax = plt.subplots(figsize=(initial_grid.shape[1], initial_grid.shape[0])) #creates a matplot figure the size fo the inital grid
  ax.axis('off')                                                                 #no axis because they were annoying
  grids = [initial_grid]                                                         # List to hold each generation's grid state
  color_logs = []                                                                #track colors of generations

  for gen in range(num_generations):
    next_grid = generation_step(grids[-1], color_density_map)                   #applies generation step function to the last grid
    color_density_map = color_density_map_update(next_grid)                     # Update allele frequencies per gen by calling density_map_update function
    grids.append(next_grid)                                                     #add grid to list for visualization

    #Keeping track of the colors + frequen cy in the list
    color_log = {"Generation": gen}                                              #creates a dictionary to keep track of generation # in column
    color_log.update({color: density for color, density in color_density_map.items()}) #updates the dictionary with the new color density map items for each gen  {((0,255,255):0.50), ((255,0,0):0.5)}
    color_logs.append(color_log)

    # Save the color logs to a CSV file. Need to figure out how to write a csv file --> could do File IO or pandas, will do pandas b/c easier
    color_df = pd.DataFrame(color_logs)
    color_df.to_csv(csv_filename)

  # Animation function ripped from github
  def update(frame):
    ax.clear()
    ax.axis('off')
    ax.imshow(grids[frame], extent=[0, initial_grid.shape[1], 0, initial_grid.shape[0]])

  #save the animation as gif ripped from github
  ani = animation.FuncAnimation(fig, update, frames=num_generations + 1, interval=interval)
  ani.save(filename, writer='imagemagick', fps=2)
  plt.close(fig)

#CAN EDIT FPS AND INTERVAL TO TOGGLE GIF OUTPUT (SPEED AND NUMBER OF FRAMES PER MILLISECOND(?), TOGGLE ITERATIONS BELOW
initial_grid = user_grid
simulate_generations_and_save_as_gif(initial_grid, color_density_map, 80, "genedrifter.gif", "color_frequency.csv")

"""# FINAL COMPOSITE CODE (NO COMMENTS / CLEAN VERSION )"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd

# INITIALIZATION

def input_colors_and_densities(alleles):
  color_density_map = {}
  total_density = 0
  for i in range(alleles-1):
    rgb_values = input("Choose a color for allele " + str(i+1) + " in RGB format (r,g,b where each value is between 0-255): ").split(',')
    color = tuple(map(int, rgb_values))

    density = float(input("Enter the relative frequency of allele " + str(i+1) + " (value between 0 and 1): "))
    color_density_map[color] = density
    total_density += density

  rgb_values = input("Choose a color for allele " + str(alleles) + " in RGB format (r,g,b).:").split(',')
  color = tuple(map(int, rgb_values))
  remaining_density = 1 - total_density
  print("The relative frequency for allele " + str(alleles) + " is set to " + str(remaining_density) + " to ensure sum equals 1.")
  color_density_map[color] = remaining_density

  print(color_density_map)
  return color_density_map

def random_grid(height, width, overall_density, color_density_map):
  grid = np.zeros((height, width, 3), dtype=np.uint8)
  colors = list(color_density_map.keys())
  densities = list(color_density_map.values())
  for i in range(height):
    for j in range(width):
      if np.random.rand() < overall_density:
        color_index = np.random.choice(len(colors), p=densities)
        grid[i, j] = colors[color_index]

  return grid

height = int(input("Enter the environment's height: "))
width = int(input("Enter the environment's width: "))
overall_density = float(input("Enter the organisms population density (value between 0 and 1): "))

alleles = int(input("Enter the number of alleles in population: "))
color_density_map = input_colors_and_densities(alleles)

user_grid = random_grid(height, width, overall_density, color_density_map)
plt.imshow(user_grid)
plt.show()

# FITNESS CALC

def color_density_map_update(grid):
  color_denisity_update = {}
  total_alive = 0
  for row in grid:
    for cell in row:
      if np.any(cell > 0):
        cell_color = tuple(cell)
        color_denisity_update[cell_color] = color_denisity_update.get(cell_color, 0) + 1
        total_alive += 1

  color_density_map_update = {color: count/total_alive for color, count in color_denisity_update.items() if total_alive > 0}
  return color_density_map_update

def fitness_function(live_neighbors, color_density_map, mutation_rate=0.01, beneficial_mutation_boost = 0.3, detrimental_mutation_penalty = -0.3):
  weighted_sum = np.array([0.0,0.0,0.0])
  total_density = 0.0

  for color in live_neighbors:
    p_color = tuple(color)
    if p_color in color_density_map:
      density = color_density_map[p_color]
      weighted_sum += np.array(color) * density
      total_density += density
  if total_density > 0:
    w_average_color = (weighted_sum / total_density).astype(int)

    if np.random.rand() < mutation_rate:
      if np.random.rand() < 0.10:
        new_color = (0,200,0)
        mutation_factor = beneficial_mutation_boost

      else:
        new_color = (250,250,0)
        mutation_factor = detrimental_mutation_penalty

      if tuple(new_color) in color_density_map:
        color_density_map[tuple(new_color)] = max(0.0, color_density_map[tuple(new_color)] + mutation_factor)
      else:
        color_density_map[tuple(new_color)] = max(0.0, 0.01 + mutation_factor)
    else:
      new_color = tuple(w_average_color)

  else:
    new_color = (0,0,0)

  return new_color

# GENERATION STEPS

def generation_step(user_grid, color_denisty_map, survival_rule=[2, 3], birth_rule=[3]):
  height , width = user_grid.shape[:2]
  next_grid = np.zeros((height, width, 3), dtype=np.uint8)

  if width >= 3 and height >= 3:
    for j in range(height):
      for i in range(width):

        live_neighbors = [user_grid[j+a][i+b] for a in (-1,0,1) for b in (-1,0,1) if (a != 0 or b != 0) and (0 <= j+a < height) and (0 <= i+b < width) and np.any(user_grid[j+a][i+b] > 0)]

        neighbor_count = len(live_neighbors)


        if np.any(user_grid[j][i]>0):
          if neighbor_count in survival_rule:
            next_grid[j,i] = user_grid[j,i]
          else:
            next_grid[j,i] = (0,0,0)


        else:
          if neighbor_count in birth_rule:
            new_color = fitness_function(live_neighbors, color_density_map)
            next_grid[j, i] = new_color

  return next_grid

def simulate_generations_and_save_as_gif(initial_grid, color_density_map, num_generations, filename, csv_filename,interval=800):
  fig, ax = plt.subplots(figsize=(initial_grid.shape[1], initial_grid.shape[0]))
  ax.axis('off')
  grids = [initial_grid]
  color_logs = []

  for gen in range(num_generations):
    next_grid = generation_step(grids[-1], color_density_map)
    color_density_map = color_density_map_update(next_grid)
    grids.append(next_grid)


    color_log = {"Generation": gen}
    color_log.update({color: density for color, density in color_density_map.items()})
    color_logs.append(color_log)

    color_df = pd.DataFrame(color_logs)
    color_df.to_csv(csv_filename)

  def update(frame):
    ax.clear()
    ax.axis('off')
    ax.imshow(grids[frame], extent=[0, initial_grid.shape[1], 0, initial_grid.shape[0]])

  ani = animation.FuncAnimation(fig, update, frames=num_generations + 1, interval=interval)
  ani.save(filename, writer='imagemagick', fps=2)
  plt.close(fig)

initial_grid = user_grid
simulate_generations_and_save_as_gif(initial_grid, color_density_map, 80, "genedrifter.gif", "color_frequency.csv")

from google.colab import drive
drive.mount('/content/drive')